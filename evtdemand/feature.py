# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/03a-feature-generation.ipynb (unless otherwise specified).

__all__ = ['dt_rng_to_SPs', 'create_temporal_features', 'create_dir_speed_features', 'add_col_suffix',
           'iterate_feature_gen_over_site_gridpoints', 'calc_hcdh_factor', 'create_hcdh_features',
           'create_prev_month_stats_df', 'create_lagged_df', 'create_additional_features', 'process_features']

# Cell
import numpy as np
import pandas as pd

from copy import copy
from evtdemand import data

# Cell
def dt_rng_to_SPs(
    start_date: pd.Timestamp,
    end_date: pd.Timestamp,
    freq: str='30T',
    tz: str='Europe/London'
):
    dt_rng = pd.date_range(start_date, end_date, freq=freq, tz=tz)

    SPs = list((2*(dt_rng.hour + dt_rng.minute/60) + 1).astype(int))
    dt_strs = list(dt_rng.strftime('%Y-%m-%d'))

    df_dates_SPs = pd.DataFrame({'date':dt_strs, 'SP':SPs}, index=dt_rng).astype(str)

    # Accounting for clock changes
    clock_change_dt_idxs_dir = pd.Series(dt_rng).apply(lambda dt: dt.utcoffset().total_seconds()).diff().replace(0, np.nan).dropna()

    for dt_idx, dir_ in clock_change_dt_idxs_dir.items():
        dt = dt_rng[dt_idx].date()
        SPs = (1 + 2*(dt_rng[dt_rng.date==dt] - pd.to_datetime(dt).tz_localize('Europe/London')).total_seconds()/(60*60)).astype(int)

        df_dates_SPs.loc[df_dates_SPs.index.date==dt, 'SP'] = SPs

    return df_dates_SPs

def create_temporal_features(df_features: pd.DataFrame):
    df_dates_SPs = dt_rng_to_SPs(
        df_features.index.min().strftime('%Y-%m-%d %H:%M'),
        df_features.index.max().strftime('%Y-%m-%d %H:%M')
    )

    df_dates_SPs.index = df_dates_SPs.index.tz_convert('UTC')

    df_temporal = pd.DataFrame({
        # 'SP': df_dates_SPs['SP'].values,
        'hour': df_features.index.hour + df_features.index.minute/60,
        'local_hour': df_features.index.tz_convert('Europe/London').hour + df_features.index.tz_convert('Europe/London').minute/60,
        'doy': df_features.index.dayofyear,
        'weekend': df_features.index.dayofweek.isin([5, 6])
    }, index=df_features.index)

    return df_temporal

# Cell
def create_dir_speed_features(df_features: pd.DataFrame, site_gridpoint: str='staplegrove_1'):
    s_U, s_V = df_features[f'windspeed_east_{site_gridpoint}'], df_features[f'windspeed_north_{site_gridpoint}']

    df_speed_dir = pd.DataFrame({
        'direction': np.mod(180 + np.rad2deg(np.arctan2(s_U, s_V)), 360),
        'speed': np.sqrt(s_U**2 + s_V**2)
    })

    return df_speed_dir

def add_col_suffix(df, col_suffix):
    df.columns = [f'{col}_{col_suffix}' for col in df.columns]

    return df

def iterate_feature_gen_over_site_gridpoints(
    df_features: pd.DataFrame,
    feature_gen_function: type(lambda x: x),
    sites: list=['staplegrove'],
    grid_points: type(None)=None,
    **kwargs
):
    """Accepts a function that can be passed `df_features` and `site_gridpoint`"""

    grid_points_original = copy(grid_points)

    for site in sites:
        if grid_points_original is None:
            grid_points = sorted(list(set([int(col.split(f'{site}_')[-1]) for col in list(df_features.columns[df_features.columns.str.contains(site)])])))

        df = pd.concat([
            feature_gen_function(df_features, f'{site}_{grid_point}', **kwargs).pipe(add_col_suffix, f'{site}_{grid_point}')
            for grid_point
            in grid_points
        ], axis=1)

    return df

# Cell
def calc_hcdh_factor(
    t: float,
    hbt: float=10,
    cbt: float=20,
    beta_0: float=0,
    beta_1: float=1,
    beta_2: float=2
):
    if isinstance(t, pd.Series):
        hdh = (hbt-t).to_frame().assign(ref=0).max(axis=1)
        cdh = (t-cbt).to_frame().assign(ref=0).max(axis=1)

    else:
        hdh = max(0, hbt-t)
        cdh = max(0, t-cbt)

    hcdh_factor = beta_0 + beta_1*hdh + beta_2*cdh

    return hcdh_factor

def create_hcdh_features(df_features: pd.DataFrame, site_gridpoint: str='staplegrove_1'):
    df_hcdh_factor = calc_hcdh_factor(df_features[f'temperature_{site_gridpoint}']).to_frame()
    df_hcdh_factor = df_hcdh_factor.rename(columns={0: f'hcdh'})

    return df_hcdh_factor

# Cell
def create_prev_month_stats_df(df_features: pd.DataFrame, df_target: pd.DataFrame):
    s_avg_to_max = df_target['value_max'] - df_features['value']
    s_avg_to_min = df_target['value_min'] - df_features['value']

    df_prev_month_stats = pd.DataFrame({
        'prev_month_max_avg': s_avg_to_max.resample('MS').mean().shift().reindex(s_avg_to_max.index).ffill().dropna(),
        'prev_month_max_max': s_avg_to_max.resample('MS').max().shift().reindex(s_avg_to_max.index).ffill().dropna(),
        'prev_month_min_avg': s_avg_to_min.resample('MS').mean().shift().reindex(s_avg_to_min.index).ffill().dropna(),
        'prev_month_min_min': s_avg_to_min.resample('MS').min().shift().reindex(s_avg_to_min.index).ffill().dropna()
    })

    return df_prev_month_stats

# Cell
def create_lagged_df(df_features: pd.DataFrame):
    df_lagged = pd.DataFrame({
        'value_lagged_1': df_features['value'].shift().bfill()
    })

    return df_lagged

# Cell
def create_additional_features(
    df_features: pd.DataFrame,
    df_target: pd.DataFrame=None,
    features: list=['temporal', 'dir_speed', 'hcdh', 'prev_month_stats', 'lagged'],
    sites: list=['staplegrove'],
    grid_points: type(None)=None
):
    if 'temporal' in features:
        df_features = df_features.merge(create_temporal_features(df_features), left_index=True, right_index=True)

    if 'dir_speed' in features:
        df_dir_speed = iterate_feature_gen_over_site_gridpoints(df_features, create_dir_speed_features, sites, grid_points)
        df_features = df_features.merge(df_dir_speed, left_index=True, right_index=True)

    if 'hcdh' in features:
        df_hcdh = iterate_feature_gen_over_site_gridpoints(df_features, create_hcdh_features, sites, grid_points)
        df_features = df_features.merge(df_hcdh, left_index=True, right_index=True)

    if 'prev_month_stats' in features:
        assert df_target is not None
        df_features = df_features.merge(create_prev_month_stats_df(df_features, df_target), left_index=True, right_index=True)

    if 'lagged' in features:
        df_features = df_features.merge(create_lagged_df(df_features), left_index=True, right_index=True)

    df_features = df_features.dropna()

    return df_features

# Cell
def process_features(
    df_features: pd.DataFrame,
    cols_subset = ['value', 'temperature_staplegrove_1', 'solar_irradiance_staplegrove_1', 'windspeed_north_staplegrove_1',
                   'windspeed_east_staplegrove_1', 'pressure_staplegrove_1', 'spec_humidity_staplegrove_1', 'hour', 'doy',
                   'weekend', 'direction_staplegrove_1', 'speed_staplegrove_1', 'hcdh_staplegrove_1'],
):
    df_features_processed = df_features.copy()

    common_cols_subset = df_features_processed.columns.intersection(pd.Index(cols_subset))
    df_features_processed = df_features_processed[common_cols_subset]

    return df_features_processed